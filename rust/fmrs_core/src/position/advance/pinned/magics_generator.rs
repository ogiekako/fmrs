use std::collections::HashMap;
use std::ops::RangeInclusive;
use std::sync::Mutex;
use std::{fs::File, ops::Index, path::PathBuf, time::Instant};

use crate::codegen::{ConstVec, DefTokens, DefWriter};
use crate::piece::Color;
use crate::position::bitboard::{lance_reachable_no_magic, power};
use crate::{
    magic::{Magic, MagicGenerator},
    piece::Kind,
    position::{
        bitboard::{bishop_reachable_no_magic, rook_reachable_no_magic},
        BitBoard, Square,
    },
};
use anyhow::bail;
use log::{debug, info};
use proc_macro2::TokenStream;
use quote::{quote, ToTokens, TokenStreamExt};
use rand::{rngs::StdRng, Rng, SeedableRng};
use rayon::prelude::*;
use std::io::Write as _;

pub fn gen_magic<R: SeedableRng + Rng>() -> anyhow::Result<()> {
    let start = Instant::now();

    let one_prob_per_100 = 10..21;

    let range = Square::S11.index()..=Square::S99.index();
    let n = range.clone().count();

    let iter = Mutex::new(0);
    let all_magics = range
        .clone()
        .into_par_iter()
        .map(|i| {
            let iter = {
                let mut iter = iter.lock().unwrap();
                *iter += 1;
                *iter
            };

            let pos = Square::from_index(i);
            info!("Generating magics for {:?} ({}/{})", pos, iter, n);

            let mut generator = MagicGenerator::new(
                R::seed_from_u64(i as u64),
                one_prob_per_100.clone(),
                1_000_000,
                0,
            );
            gen_magics(&mut generator, pos)
        })
        .collect::<Result<Vec<_>, _>>()?;

    let elapsed = start.elapsed();

    all_magics
        .par_iter()
        .zip(range.clone().collect::<Vec<_>>())
        .for_each(|(magics, i)| {
            magics.check(Square::from_index(i));
        });

    let total_len: usize = all_magics.iter().map(|m| m.total_len()).sum();
    info!(
        "Found {} magics in {:.1?}; total length: {}",
        all_magics.len(),
        elapsed,
        total_len,
    );

    let mut const_magics: ConstMagics = all_magics.as_slice().into();
    const_magics.range = range;

    let comment = format!("Generated by gen-magic: total_len={total_len} elapsed={elapsed:.1?}");

    let mut defs = DefWriter::new();
    ConstMagics::def_tokens(&mut defs);
    let defs = defs.finish();

    let mut core = quote! {};
    const_magics.to_tokens(&mut core);

    let file = PathBuf::from(file!());
    let dir = file.parent().unwrap();
    let included_file_name = "generated_magics_incl.rs";
    let gmi = dir.join(included_file_name);

    writeln!(&mut File::create(&gmi)?, "{}", core)?;

    // Set --features=gen-magic to regenerate broken file.
    let ts = quote! {
        #![allow(clippy::all, unused)]
        #[doc = #comment]

        #defs

        #[cfg(feature="gen-magic")]
        pub fn lance_pinning(occupied: BitBoard, king_color: Color, pos: Square) -> BitBoard {
            unimplemented!()
        }
        #[cfg(feature="gen-magic")]
        pub fn bishop_pinning(occupied: BitBoard, pos: Square) -> BitBoard {
            unimplemented!()
        }
        #[cfg(feature="gen-magic")]
        pub fn rook_pinning(occupied: BitBoard, pos: Square) -> BitBoard {
            unimplemented!()
        }

        #[cfg(not(feature="gen-magic"))]
        include!(#included_file_name);
    };
    let gm = dir.join("generated_magics.rs");
    writeln!(&mut File::create(&gm)?, "{}", ts)?;

    std::process::Command::new("rustfmt")
        .arg(gm)
        .arg(gmi)
        .status()
        .map_err(|e| anyhow::anyhow!("failed to run rustfmt: {}", e))?;

    Ok(())
}

#[derive(Clone, Debug)]
struct Offset {
    ids_offset: usize,
    all_offset: usize,
}

impl Offset {
    fn new(ids_offset: usize, all_offset: usize) -> Self {
        Self {
            ids_offset,
            all_offset,
        }
    }
}

impl Index<usize> for Offset {
    type Output = BitBoard;

    fn index(&self, _index: usize) -> &Self::Output {
        unimplemented!("dummy")
    }
}

#[derive(Clone, Debug)]
struct ConstMagics {
    range: RangeInclusive<usize>,
    all: Vec<BitBoard>,
    ids: Vec<u8>,
    magics: Vec<Magics<Offset>>,
}

impl DefTokens for Offset {
    fn def_tokens(w: &mut DefWriter) {
        w.write(
            "Offset",
            quote! {
                struct Offset {
                    ids_offset: usize,
                    all_offset: usize,
                }
                #[cfg(not(feature="gen-magic"))]
                impl std::ops::Index<usize> for Offset {
                    type Output = BitBoard;
                    fn index(&self, index: usize) -> &Self::Output {
                        &ALL[self.all_offset + IDS[self.ids_offset + index] as usize]
                    }
                }
            },
        );
    }
}

impl ToTokens for Offset {
    fn to_tokens(&self, w: &mut TokenStream) {
        let ids_offset = self.ids_offset;
        let all_offset = self.all_offset;
        w.append_all(quote! {
            Offset {
                ids_offset: #ids_offset,
                all_offset: #all_offset,
            }
        });
    }
}

impl<T: DefTokens> DefTokens for Magics<T> {
    fn def_tokens(w: &mut DefWriter) {
        PackMagic::<T>::def_tokens(w);
        Color::def_tokens(w);
        w.write(
            "Magics",
            quote! {
                use crate::position::advance::pinned::magics_generator::Magics;
            },
        );
    }
}

impl<T: ToTokens> ToTokens for Magics<T> {
    fn to_tokens(&self, w: &mut TokenStream) {
        let lance = &self.lance;
        let bishop = &self.bishop;
        let rook = &self.rook;
        w.append_all(quote! {
            Magics {
                lance: [#(#lance),*],
                bishop: #bishop,
                rook: #rook,
            }
        });
    }
}

impl DefTokens for ConstMagics {
    fn def_tokens(w: &mut DefWriter) {
        Square::def_tokens(w);
        BitBoard::def_tokens(w);
        Magics::<Offset>::def_tokens(w);
    }
}

impl ToTokens for ConstMagics {
    fn to_tokens(&self, w: &mut TokenStream) {
        let ids = ConstVec::new(quote!(IDS), quote!(u8), &self.ids);
        let all = ConstVec::new(quote!(ALL), quote!(BitBoard), &self.all);
        let magics = ConstVec::new(quote!(MAGICS), quote!(Magics<Offset>), &self.magics);
        let start = self.range.start();
        let end = self.range.end();

        w.append_all(quote! {
            #all
            #ids
            #magics

            pub fn lance_pinning(occupied: BitBoard, king_color: Color, pos: Square) -> BitBoard {
                MAGICS[pos.index()].lance_pinning(occupied, king_color)
            }

            pub fn bishop_pinning(occupied: BitBoard, pos: Square) -> BitBoard {
                MAGICS[pos.index()].bishop_pinning(occupied)
            }

            pub fn rook_pinning(occupied: BitBoard, pos: Square) -> BitBoard {
                MAGICS[pos.index()].rook_pinning(occupied)
            }

            #[cfg(test)]
            mod tests {
                use super::*;

                #[test]
                fn test_const_magics() {
                    for (magics, i) in MAGICS.iter().zip(#start..=#end) {
                        magics.check(Square::from_index(i));
                    }
                }
            }
        });
    }
}

impl From<&[Magics<Vec<BitBoard>>]> for ConstMagics {
    fn from(all_magics: &[Magics<Vec<BitBoard>>]) -> Self {
        let mut ids = vec![];
        let mut all = vec![];

        let mut f = |table: &[BitBoard]| {
            let res = Offset::new(ids.len(), all.len());
            let mut bbs = HashMap::new();
            for &bb in table.iter() {
                if let Some(&i) = bbs.get(&bb) {
                    ids.push(i);
                } else {
                    let i = (all.len() - res.all_offset) as u8;
                    all.push(bb);
                    bbs.insert(bb, i);
                    ids.push(i);
                }
            }
            res
        };

        let mut magics = vec![];
        for m in all_magics {
            let lance0 = m.lance[0].clone_with(f(&m.lance[0].core.table));
            let lance1 = m.lance[1].clone_with(f(&m.lance[1].core.table));
            let bishop = m.bishop.clone_with(f(&m.bishop.core.table));
            let rook = m.rook.clone_with(f(&m.rook.core.table));

            magics.push(Magics {
                lance: [lance0, lance1],
                bishop,
                rook,
            });
        }
        Self {
            range: 0..=magics.len() - 1,
            ids,
            all,
            magics,
        }
    }
}

fn pack(occupied: BitBoard, shift: u32) -> u64 {
    let (a, b) = occupied.high_low();
    a | b.rotate_left(shift)
}

#[derive(Clone, Debug)]
pub(super) struct PackMagic<T> {
    pub(super) shift: u32,
    pub(super) occupied_mask: BitBoard,
    pub(super) core: Magic<BitBoard, T>,
}

impl<T> PackMagic<T> {
    fn clone_with<S>(&self, table: S) -> PackMagic<S> {
        PackMagic {
            shift: self.shift,
            occupied_mask: self.occupied_mask,
            core: self.core.clone_with(table),
        }
    }
}

impl<T> PackMagic<T>
where
    T: Index<usize, Output = BitBoard>,
{
    pub(super) fn f(&self, occupied: BitBoard) -> BitBoard {
        *self.core.f(pack(occupied & self.occupied_mask, self.shift))
    }
}

impl<T: DefTokens> DefTokens for PackMagic<T> {
    fn def_tokens(w: &mut DefWriter) {
        BitBoard::def_tokens(w);
        Magic::<BitBoard, T>::def_tokens(w);
        w.write(
            "PackMagic",
            quote! {
                use crate::position::advance::pinned::magics_generator::PackMagic;
            },
        );
    }
}

impl<T: ToTokens> ToTokens for PackMagic<T> {
    fn to_tokens(&self, w: &mut TokenStream) {
        let shift = self.shift;
        let occupied_mask = self.occupied_mask;
        let core = &self.core;
        w.append_all(quote! {
            PackMagic {
                shift: #shift,
                occupied_mask: #occupied_mask,
                core: #core,
            }
        });
    }
}

#[derive(Clone, Debug)]
pub(super) struct Magics<T> {
    pub(super) lance: [PackMagic<T>; 2],
    pub(super) bishop: PackMagic<T>,
    pub(super) rook: PackMagic<T>,
}

impl<T> Magics<T>
where
    T: Index<usize, Output = BitBoard>,
{
    #[cfg(not(feature = "gen-magic"))]
    pub(super) fn lance_pinning(&self, occupied: BitBoard, king_color: Color) -> BitBoard {
        self.lance[king_color.index()].f(occupied)
    }

    #[cfg(not(feature = "gen-magic"))]
    pub(super) fn bishop_pinning(&self, occupied: BitBoard) -> BitBoard {
        self.bishop.f(occupied)
    }

    #[cfg(not(feature = "gen-magic"))]
    pub(super) fn rook_pinning(&self, occupied: BitBoard) -> BitBoard {
        self.rook.f(occupied)
    }

    pub(super) fn check(&self, pos: Square) {
        let mut rng = StdRng::seed_from_u64(202501251542 + pos.index() as u64);
        for _ in 0..10000 {
            let one_prob_per_100 = rng.gen_range(1..50);
            let mut occupied = BitBoard::EMPTY;
            for pos in Square::iter() {
                if rng.gen_range(0..100) < one_prob_per_100 {
                    occupied.set(pos);
                }
            }
            let mut attackers = BitBoard::EMPTY;
            for _ in 0..2 {
                attackers.set(rng.gen());
            }

            for king_color in Color::iter() {
                let want_lance = pinning_no_magic(occupied, pos, king_color, Kind::Lance);
                let got_lance = self.lance[king_color.index()].f(occupied);
                assert_eq!(want_lance, got_lance);
            }

            let want_bishop = pinning_no_magic(occupied, pos, Color::BLACK, Kind::Bishop);
            let got_bishop = self.bishop.f(occupied);
            assert_eq!(want_bishop, got_bishop);

            let want_rook = pinning_no_magic(occupied, pos, Color::BLACK, Kind::Rook);
            let got_rook = self.rook.f(occupied);
            assert_eq!(want_rook, got_rook);
        }
    }
}

fn pinning_no_magic(
    mut occupied: BitBoard,
    pos: Square,
    king_color: Color,
    kind: Kind,
) -> BitBoard {
    for edge in [
        BitBoard::COL1,
        BitBoard::COL9,
        BitBoard::ROW1,
        BitBoard::ROW9,
    ] {
        if !edge.contains(pos) {
            occupied |= edge;
        }
    }

    let reachable = |bb, pos| match kind {
        Kind::Bishop => bishop_reachable_no_magic(bb, pos),
        Kind::Rook => rook_reachable_no_magic(bb, pos),
        Kind::Lance => lance_reachable_no_magic(bb, king_color, pos),
        _ => unreachable!(),
    };
    let reach = reachable(occupied, pos);
    occupied.and_not(reach) & reachable(occupied.and_not(reach), pos)
}

impl<V> Magics<Vec<V>> {
    fn total_len(&self) -> usize {
        self.bishop.core.table.len() + self.rook.core.table.len()
    }
}

fn gen_magics<R: SeedableRng + Rng>(
    generator: &mut MagicGenerator<R>,
    pos: Square,
) -> anyhow::Result<Magics<Vec<BitBoard>>> {
    let mut lances_rook_bishop = [
        (Color::BLACK, Kind::Lance),
        (Color::WHITE, Kind::Lance),
        (Color::BLACK, Kind::Rook),
        (Color::BLACK, Kind::Bishop),
    ]
    .iter()
    .map(|&(king_color, kind)| {
        let power = power(king_color, pos, kind);
        let mut occupied_mask = power;
        for edge in [
            BitBoard::COL1,
            BitBoard::COL9,
            BitBoard::ROW1,
            BitBoard::ROW9,
        ] {
            if !edge.contains(pos) {
                occupied_mask.and_not_assign(edge);
            }
        }

        let shifts = (0..64)
            .filter(|&shift| pack(occupied_mask, shift).count_ones() == occupied_mask.count_ones())
            .collect::<Vec<_>>();

        if shifts.is_empty() {
            bail!("no shifts: {pos:?} {kind:?}");
        }

        debug!("{pos:?} {kind:?} shifts={}/64", shifts.len());

        for &shift in shifts.iter() {
            let mut map = HashMap::new();
            for occupied in occupied_mask.subsets() {
                let packed = pack(occupied, shift);
                debug_assert!(!map.contains_key(&packed));

                let pinned = pinning_no_magic(occupied, pos, king_color, kind);

                // if map.len() % 100 == 0 {
                //     debug!("{pos:?} {kind:?} {occupied:?} {attackers:?} {:?}", pinned);
                // }

                map.insert(packed, pinned);
            }
            match generator.gen_magic(map, &format!("{:?} {:?} shift={:?}", pos, kind, shift)) {
                Ok(core) => {
                    return Ok(PackMagic {
                        shift,
                        occupied_mask,
                        core,
                    })
                }
                Err(e) => {
                    debug!("{e}");
                }
            };
        }
        bail!("no magic found: {pos:?} {kind:?}");
    })
    .collect::<Result<Vec<_>, _>>()?;

    let lance = [lances_rook_bishop.remove(0), lances_rook_bishop.remove(0)];
    let rook = lances_rook_bishop.remove(0);
    let bishop = lances_rook_bishop.remove(0);

    Ok(Magics {
        lance,
        bishop,
        rook,
    })
}

#[cfg(test)]
mod tests {
    use crate::bitboard;

    use super::*;

    #[test]
    fn test_pinned_no_magic() {
        let occupied = bitboard!(
            "*.......*",
            "........*",
            "........*",
            ".....*..*",
            "........*",
            "...*....*",
            "........*",
            "........*",
            "*........",
        );
        let king = Square::S11;
        let want_lance_pinning = BitBoard::EMPTY.with(Square::S13);
        let want_bishop_pinning = BitBoard::EMPTY.with(Square::S66);
        let want_rook_pinning = BitBoard::EMPTY.with(Square::S13);

        assert_eq!(
            pinning_no_magic(occupied, king, Color::WHITE, Kind::Lance),
            want_lance_pinning
        );
        assert_eq!(
            pinning_no_magic(occupied, king, Color::BLACK, Kind::Bishop),
            want_bishop_pinning
        );
        assert_eq!(
            pinning_no_magic(occupied, king, Color::BLACK, Kind::Rook),
            want_rook_pinning
        );
    }
}
