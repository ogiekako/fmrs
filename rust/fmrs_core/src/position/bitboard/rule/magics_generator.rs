use std::{
    collections::HashMap,
    fs::File,
    io::Write,
    ops::{Index, RangeInclusive},
    path::PathBuf,
    time::Instant,
};

use crate::{
    codegen::{ConstVec, DefTokens, DefWriter},
    magic::{Magic, MagicGenerator},
    piece::Color,
    position::{
        bitboard::{
            bishop_reachable_no_magic, king_power, lance_reachable_no_magic,
            rook_reachable_no_magic,
        },
        BitBoard, Square,
    },
};
use anyhow::Context;
use log::info;
use proc_macro2::TokenStream;
use quote::{quote, ToTokens, TokenStreamExt};
use rand::{rngs::StdRng, Rng, SeedableRng};
use rayon::prelude::*;

use super::{bishop_power, lance_power, rook_power};

pub fn gen_magic<R: SeedableRng + Rng>() -> anyhow::Result<()> {
    let start = Instant::now();

    let one_prob_per_100 = 10..21;

    let range = Square::S11.index()..=Square::S99.index();

    let all_magics = range
        .clone()
        .into_par_iter()
        .map(|i| {
            let pos = Square::from_index(i);
            info!("Generating magics for {:?}", pos);

            let retries = 10;
            let mut generator = MagicGenerator::new(
                R::seed_from_u64(i as u64),
                one_prob_per_100.clone(),
                2_000_000,
                0,
            );
            gen_magics(&mut generator, pos, retries)
        })
        .collect::<Result<Vec<_>, _>>()?;

    let elapsed = start.elapsed();

    all_magics
        .par_iter()
        .zip(range.clone().collect::<Vec<_>>())
        .for_each(|(magics, i)| {
            magics.check(Square::from_index(i));
        });

    let total_len: usize = all_magics.iter().map(|m| m.total_len()).sum();
    info!(
        "Found {} magics in {:.1?}; total length: {}",
        all_magics.len(),
        elapsed,
        total_len,
    );

    let mut const_magics: ConstMagics = all_magics.as_slice().into();
    const_magics.range = range;

    let comment = format!("Generated by gen-magic: total_len={total_len} elapsed={elapsed:.1?}");

    let mut defs = DefWriter::new();
    ConstMagics::def_tokens(&mut defs);
    let defs = defs.finish();

    let mut core = quote! {};
    const_magics.to_tokens(&mut core);

    let file = PathBuf::from(file!());
    let dir = file.parent().unwrap();
    let included_file_name = "generated_magics_incl.rs";
    let gmi = dir.join(included_file_name);

    writeln!(&mut File::create(&gmi)?, "{}", core)?;

    // Set --features=gen-magic to regenerate broken file.
    let ts = quote! {
        #![allow(clippy::all, unused)]
        #[doc = #comment]

        #defs

        #[cfg(feature="gen-magic")]
        pub fn lance_reachable(occupied: BitBoard, color: Color, pos: Square) -> BitBoard {
            unimplemented!()
        }
        #[cfg(feature="gen-magic")]
        pub fn bishop_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
            unimplemented!()
        }
        #[cfg(feature="gen-magic")]
        pub fn pro_bishop_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
            unimplemented!()
        }
        #[cfg(feature="gen-magic")]
        pub fn rook_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
            unimplemented!()
        }
        #[cfg(feature="gen-magic")]
        pub fn pro_rook_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
            unimplemented!()
        }

        #[cfg(not(feature="gen-magic"))]
        include!(#included_file_name);
    };
    let gm = dir.join("generated_magics.rs");
    writeln!(&mut File::create(&gm)?, "{}", ts)?;

    std::process::Command::new("rustfmt")
        .arg(gm)
        .arg(gmi)
        .status()
        .map_err(|e| anyhow::anyhow!("failed to run rustfmt: {}", e))?;

    Ok(())
}

#[derive(Clone, Debug)]
struct Offset {
    ids_offset: usize,
    all_offset: usize,
}

impl Offset {
    const fn new(ids_offset: usize, all_offset: usize) -> Self {
        Self {
            ids_offset,
            all_offset,
        }
    }
}

impl Index<usize> for Offset {
    type Output = BitBoard;

    fn index(&self, _index: usize) -> &Self::Output {
        unimplemented!("dummy")
    }
}

#[derive(Clone, Debug)]
struct ConstMagics {
    range: RangeInclusive<usize>,
    all: Vec<BitBoard>,
    ids: Vec<u8>,
    magics: Vec<Magics<Offset>>,
}

impl DefTokens for Offset {
    fn def_tokens(w: &mut DefWriter) {
        w.write(
            "Offset",
            quote! {
                struct Offset {
                    ids_offset: usize,
                    all_offset: usize,
                }
                #[cfg(not(feature="gen-magic"))]
                impl std::ops::Index<usize> for Offset {
                    type Output = BitBoard;
                    fn index(&self, index: usize) -> &Self::Output {
                        &ALL[self.all_offset + IDS[self.ids_offset + index] as usize]
                    }
                }
            },
        );
    }
}

impl ToTokens for Offset {
    fn to_tokens(&self, w: &mut TokenStream) {
        let ids_offset = self.ids_offset;
        let all_offset = self.all_offset;
        w.append_all(quote! {
            Offset {
                ids_offset: #ids_offset,
                all_offset: #all_offset,
            }
        });
    }
}

impl<T: DefTokens> DefTokens for Magics<T> {
    fn def_tokens(w: &mut DefWriter) {
        w.write(
            "Magics",
            quote! {
                use crate::position::bitboard::rule::magics_generator::Magics;
            },
        );
        PackMagic::<T>::def_tokens(w);
        BitBoard::def_tokens(w);
    }
}

impl<T: ToTokens> ToTokens for Magics<T> {
    fn to_tokens(&self, w: &mut TokenStream) {
        let lance0 = &self.lance[0];
        let lance1 = &self.lance[1];
        let bishop = &self.bishop;
        let rook = &self.rook;
        let king = self.king;
        w.append_all(quote! {
            Magics {
                lance: [#lance0, #lance1],
                bishop: #bishop,
                rook: #rook,
                king: #king,
            }
        });
    }
}

impl DefTokens for ConstMagics {
    fn def_tokens(w: &mut DefWriter) {
        w.write(
            "ConstMagics",
            quote! {
                use crate::piece::Color;
                use crate::position::bitboard::Square;
            },
        );
        Magics::<Offset>::def_tokens(w);
    }
}

impl ToTokens for ConstMagics {
    fn to_tokens(&self, w: &mut TokenStream) {
        let ids = ConstVec::new(quote!(IDS), quote!(u8), &self.ids);
        let all = ConstVec::new(quote!(ALL), quote!(BitBoard), &self.all);
        let magics = ConstVec::new(quote!(MAGICS), quote!(Magics<Offset>), &self.magics);
        let start = self.range.start();
        let end = self.range.end();
        w.append_all(quote! {
            #all
            #ids
            #magics

            pub fn lance_reachable(occupied: BitBoard, color: Color, pos: Square) -> BitBoard {
                MAGICS[pos.index()].lance_reachable(occupied, color)
            }
            pub fn bishop_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
                MAGICS[pos.index()].bishop_reachable(occupied)
            }
            pub fn pro_bishop_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
                MAGICS[pos.index()].pro_bishop_reachable(occupied)
            }
            pub fn rook_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
                MAGICS[pos.index()].rook_reachable(occupied)
            }
            pub fn pro_rook_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
                MAGICS[pos.index()].pro_rook_reachable(occupied)
            }

            #[cfg(test)]
            mod tests {
                use super::*;

                #[test]
                fn test_const_magics() {
                    for (magics, i) in MAGICS.iter().zip(#start..=#end) {
                        magics.check(Square::from_index(i));
                    }
                }
            }
        });
    }
}

impl From<&[Magics<Vec<BitBoard>>]> for ConstMagics {
    fn from(all_magics: &[Magics<Vec<BitBoard>>]) -> Self {
        let mut ids = vec![];
        let mut all = vec![];

        let mut f = |table: &[BitBoard]| {
            let res = Offset::new(ids.len(), all.len());
            let mut bbs = HashMap::new();
            for &bb in table.iter() {
                if let Some(&i) = bbs.get(&bb) {
                    ids.push(i);
                } else {
                    let i = (all.len() - res.all_offset) as u8;
                    all.push(bb);
                    bbs.insert(bb, i);
                    ids.push(i);
                }
            }
            res
        };

        let mut magics = vec![];
        for m in all_magics {
            let lance0 = m.lance[0].clone_with(f(&m.lance[0].core.table));
            let lance1 = m.lance[1].clone_with(f(&m.lance[1].core.table));
            let bishop = m.bishop.clone_with(f(&m.bishop.core.table));
            let rook = m.rook.clone_with(f(&m.rook.core.table));

            magics.push(Magics {
                lance: [lance0, lance1],
                bishop,
                rook,
                king: m.king,
            });
        }
        Self {
            range: 0..=magics.len() - 1,
            ids,
            all,
            magics,
        }
    }
}

#[derive(Clone, Debug)]
pub(super) struct Magics<T> {
    pub(super) lance: [PackMagic<T>; 2],
    pub(super) bishop: PackMagic<T>,
    pub(super) rook: PackMagic<T>,
    pub(super) king: BitBoard,
}

#[derive(Clone, Debug)]
pub(super) struct PackMagic<T> {
    pub(super) shift: u32,
    pub(super) full: BitBoard,
    pub(super) core: Magic<BitBoard, T>,
}

impl<T> PackMagic<T> {
    fn clone_with<S>(&self, table: S) -> PackMagic<S> {
        PackMagic {
            shift: self.shift,
            full: self.full,
            core: self.core.clone_with(table),
        }
    }
}

impl<T> PackMagic<T>
where
    T: Index<usize, Output = BitBoard>,
{
    pub(super) fn f(&self, bb: BitBoard) -> BitBoard {
        *self.core.f(pack(bb & self.full, self.shift))
    }
}

impl<T: DefTokens> DefTokens for PackMagic<T> {
    fn def_tokens(w: &mut DefWriter) {
        T::def_tokens(w);
        w.write(
            "PackMagic",
            quote! {
                use crate::position::bitboard::rule::magics_generator::PackMagic;
                use crate::magic::Magic;
            },
        );
    }
}

impl<T: ToTokens> ToTokens for PackMagic<T> {
    fn to_tokens(&self, w: &mut TokenStream) {
        let shift = self.shift;
        let full = self.full;
        let core = &self.core;
        w.append_all(quote! {
            PackMagic {
                shift: #shift,
                full: #full,
                core: #core,
            }
        });
    }
}

impl<T> Magics<T>
where
    T: Index<usize, Output = BitBoard>,
{
    #[cfg(not(feature = "gen-magic"))]
    pub(super) fn lance_reachable(&self, occupied: BitBoard, color: Color) -> BitBoard {
        self.lance[color.index()].f(occupied)
    }

    #[cfg(not(feature = "gen-magic"))]
    pub(super) fn bishop_reachable(&self, occupied: BitBoard) -> BitBoard {
        self.bishop.f(occupied)
    }

    #[cfg(not(feature = "gen-magic"))]
    pub(super) fn pro_bishop_reachable(&self, occupied: BitBoard) -> BitBoard {
        self.bishop.f(occupied) | self.king
    }

    #[cfg(not(feature = "gen-magic"))]
    pub(super) fn rook_reachable(&self, occupied: BitBoard) -> BitBoard {
        self.rook.f(occupied)
    }

    #[cfg(not(feature = "gen-magic"))]
    pub(super) fn pro_rook_reachable(&self, occupied: BitBoard) -> BitBoard {
        self.rook.f(occupied) | self.king
    }

    pub(super) fn check(&self, pos: Square) {
        let mut rng = StdRng::seed_from_u64(202501202000 + pos.index() as u64);
        for _ in 0..10000 {
            let one_prob_per_100 = rng.gen_range(1..50);
            let mut occupied = BitBoard::EMPTY;
            for pos in Square::iter() {
                if rng.gen_range(0..100) < one_prob_per_100 {
                    occupied.set(pos);
                }
            }

            for c in Color::iter() {
                assert_eq!(
                    self.lance[c.index()].f(occupied),
                    lance_reachable_no_magic(occupied, c, pos)
                );
            }
            assert_eq!(
                self.bishop.f(occupied),
                bishop_reachable_no_magic(occupied, pos)
            );
            assert_eq!(
                self.rook.f(occupied),
                rook_reachable_no_magic(occupied, pos)
            );
        }
    }
}

impl Magics<Vec<BitBoard>> {
    fn total_len(&self) -> usize {
        self.bishop.core.table.len() + self.rook.core.table.len()
    }
}

fn gen_magics<R: SeedableRng + Rng>(
    generator: &mut MagicGenerator<R>,
    pos: Square,
    retries: usize,
) -> anyhow::Result<Magics<Vec<BitBoard>>> {
    let mut lance_full = [0, 1].map(|i| lance_power(Color::from_index(i), pos));
    let mut bishop_full = bishop_power(pos);
    let mut rook_full = rook_power(pos);
    for edge in [
        BitBoard::COL1,
        BitBoard::COL9,
        BitBoard::ROW1,
        BitBoard::ROW9,
    ] {
        if !edge.contains(pos) {
            lance_full[0].and_not_assign(edge);
            lance_full[1].and_not_assign(edge);
            rook_full.and_not_assign(edge);
            bishop_full.and_not_assign(edge);
        }
    }

    let mut gen_magic = |map: &HashMap<BitBoard, BitBoard>, log_prefix: &str| {
        let full = map.keys().fold(BitBoard::EMPTY, |bb, &x| bb | x);
        let mut err = None;
        for _ in 0..retries {
            for shift in 0..64 {
                if pack(full, shift).count_ones() != full.count_ones() {
                    continue;
                }
                let f = map
                    .iter()
                    .map(|(&bb, &reachable)| (pack(bb, shift), reachable))
                    .collect();
                match generator.gen_magic(f, log_prefix) {
                    Ok(core) => return Ok(PackMagic { shift, full, core }),
                    Err(e) => {
                        err = Some(Err(e));
                    }
                }
            }
        }
        err.unwrap().context(format!("retried {} times", retries))
    };

    let [black_lance_map, white_lance_map] = [0, 1].map(|i| {
        lance_full[i]
            .subsets()
            .map(|bb| (bb, lance_reachable_no_magic(bb, Color::from_index(i), pos)))
            .collect()
    });
    let bishop_map = bishop_full
        .subsets()
        .map(|bb| (bb, bishop_reachable_no_magic(bb, pos)))
        .collect();
    let rook_map = rook_full
        .subsets()
        .map(|bb| (bb, rook_reachable_no_magic(bb, pos)))
        .collect();

    let lance = [
        gen_magic(&black_lance_map, &format!("black lance {:?}", pos))?,
        gen_magic(&white_lance_map, &format!("white lance {:?}", pos))?,
    ];
    let rook = gen_magic(&rook_map, &format!("rook {:?}", pos))?;
    let bishop = gen_magic(&bishop_map, &format!("bishop {:?}", pos))?;

    Ok(Magics {
        lance,
        bishop,
        rook,
        king: king_power(pos),
    })
}

fn pack(bb: BitBoard, shift: u32) -> u64 {
    let x = bb.u128();
    let lower = (x as u64).rotate_left(shift);
    let upper = (x >> 64) as u64;
    lower | upper
}
