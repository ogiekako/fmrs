use std::{
    fs::File,
    io::Write,
    ops::{Index, RangeInclusive},
    path::PathBuf,
    time::Instant,
};

use crate::{
    codegen::WriteCode,
    magic::MagicGenerator,
    position::{
        bitboard::{bishop_reachable_no_magic, king_power, rook_reachable_no_magic},
        BitBoard, Square,
    },
};
use log::info;
use quote::{quote, TokenStreamExt};
use rand::{rngs::StdRng, Rng, SeedableRng};
use rayon::prelude::*;

use super::{bishop_power, rook_power};

pub fn gen_magic<R: SeedableRng + Rng>() -> anyhow::Result<()> {
    let start = Instant::now();

    let one_prob_per_100 = 10..21;

    let range = Square::S11.index()..=Square::S99.index();

    let all_magics = range
        .clone()
        .into_par_iter()
        .map(|i| {
            let pos = Square::from_index(i);
            info!("generating magics for {:?}", pos);

            let mut generator = MagicGenerator::new(
                R::seed_from_u64(i as u64),
                one_prob_per_100.clone(),
                10_000_000,
                100,
            );
            gen_magics(&mut generator, pos)
        })
        .collect::<Result<Vec<_>, _>>()?;

    let elapsed = start.elapsed();

    all_magics
        .par_iter()
        .zip(range.clone().collect::<Vec<_>>())
        .for_each(|(magics, i)| {
            magics.check(Square::from_index(i));
        });

    let total_len: usize = all_magics.iter().map(|m| m.total_len()).sum();
    info!(
        "found {} magics in {:.1?}; total length: {}",
        all_magics.len(),
        elapsed,
        total_len,
    );

    let mut const_magics: ConstMagics = all_magics.as_slice().into();
    const_magics.range = range;

    let comment = format!("Generated by gen-magic: total_len={total_len} elapsed={elapsed:.1?}");

    let mut defs = quote! {};
    ConstMagics::write_def(&mut defs);
    let mut core = quote! {};
    const_magics.write_value(&mut core);

    let file = PathBuf::from(file!());
    let dir = file.parent().unwrap();
    let included_file_name = "generated_magics_incl.rs";
    let gmi = dir.join(included_file_name);

    writeln!(&mut File::create(&gmi)?, "{}", core)?;

    // Set --features=gen-magic to regenerate broken file.
    let ts = quote! {
        #![allow(clippy::all, unused)]
        #[doc = #comment]

        #defs

        #[cfg(feature="gen-magic")]
        pub fn bishop_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
            unimplemented!()
        }
        #[cfg(feature="gen-magic")]
        pub fn pro_bishop_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
            unimplemented!()
        }
        #[cfg(feature="gen-magic")]
        pub fn rook_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
            unimplemented!()
        }
        #[cfg(feature="gen-magic")]
        pub fn pro_rook_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
            unimplemented!()
        }

        #[cfg(not(feature="gen-magic"))]
        include!(#included_file_name);
    };
    let gm = dir.join("generated_magics.rs");
    writeln!(&mut File::create(&gm)?, "{}", ts)?;

    std::process::Command::new("rustfmt")
        .arg(gm)
        .arg(gmi)
        .status()
        .map_err(|e| anyhow::anyhow!("failed to run rustfmt: {}", e))?;

    Ok(())
}

struct Offset(usize);

impl Index<usize> for Offset {
    type Output = BitBoard;

    fn index(&self, _index: usize) -> &Self::Output {
        unimplemented!("dummy")
    }
}

struct ConstMagics {
    range: RangeInclusive<usize>,
    all: Vec<BitBoard>,
    magics: Vec<Magics<Offset>>,
}

impl WriteCode for Offset {
    fn write_def(w: &mut impl TokenStreamExt) {
        w.append_all(quote! {
            pub struct Offset(usize);
            #[cfg(not(feature="gen-magic"))]
            impl std::ops::Index<usize> for Offset {
                type Output = BitBoard;
                fn index(&self, index: usize) -> &Self::Output {
                    &ALL[index + self.0]
                }
            }
        });
    }
    fn write_value(&self, w: &mut impl TokenStreamExt) {
        let x = self.0;
        w.append_all(quote! {
            Offset(#x)
        });
    }
}

impl WriteCode for Magics<Offset> {
    fn write_def(w: &mut impl TokenStreamExt) {
        w.append_all(quote! {
            use crate::position::bitboard::rule::magics_generator::Magics;
        });
    }
    fn write_value(&self, w: &mut impl TokenStreamExt) {
        let bishop = self.bishop.tokens();
        let rook = self.rook.tokens();
        let king = self.king.tokens();
        w.append_all(quote! {
            Magics {
                bishop: #bishop,
                rook: #rook,
                king: #king,
            }
        });
    }
}

impl WriteCode for Magic<Offset> {
    fn write_def(w: &mut impl TokenStreamExt) {
        w.append_all(quote! {
            use crate::position::bitboard::rule::magics_generator::Magic;
        });
    }
    fn write_value(&self, w: &mut impl TokenStreamExt) {
        let pack_shift = self.pack_shift;
        let magic_shift = self.magic_shift;
        let full_block = self.full_block.tokens();
        let magic = self.magic;
        let table = self.table.tokens();
        w.append_all(quote! {
            Magic {
                pack_shift: #pack_shift,
                magic_shift: #magic_shift,
                full_block: #full_block,
                magic: #magic,
                table: #table,
            }
        });
    }
}

impl ConstMagics {
    fn write_def(w: &mut impl TokenStreamExt) {
        w.append_all(quote! {
            use crate::position::bitboard::Square;
        });
        BitBoard::write_def(w);
        Offset::write_def(w);
        Magic::<Offset>::write_def(w);
        Magics::<Offset>::write_def(w);
    }
    fn write_value(&self, w: &mut impl TokenStreamExt) {
        let all = self.all.tokens();
        let magics = self.magics.tokens();
        let all_len = self.all.len();
        let magics_len = self.magics.len();
        let start = self.range.start();
        let end = self.range.end();
        w.append_all(quote! {
            const ALL: [BitBoard; #all_len] = #all;
            const MAGICS: [Magics<Offset>; #magics_len] = #magics;

            pub fn bishop_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
                MAGICS[pos.index()].bishop_reachable(occupied)
            }
            pub fn pro_bishop_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
                MAGICS[pos.index()].pro_bishop_reachable(occupied)
            }
            pub fn rook_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
                MAGICS[pos.index()].rook_reachable(occupied)
            }
            pub fn pro_rook_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
                MAGICS[pos.index()].pro_rook_reachable(occupied)
            }

            #[cfg(test)]
            mod tests {
                use super::*;

                #[test]
                fn test_const_magics() {
                    for (magics, i) in MAGICS.iter().zip(#start..=#end) {
                        magics.check(Square::from_index(i));
                    }
                }
            }
        });
    }
}

impl From<&[Magics<Vec<BitBoard>>]> for ConstMagics {
    fn from(all_magics: &[Magics<Vec<BitBoard>>]) -> Self {
        let mut all = vec![];

        let mut magics = vec![];
        for m in all_magics {
            let bishop = m.bishop.clone_with(Offset(all.len()));
            all.extend_from_slice(&m.bishop.table);
            let rook = m.rook.clone_with(Offset(all.len()));
            all.extend_from_slice(&m.rook.table);

            magics.push(Magics {
                bishop,
                rook,
                king: m.king,
            });
        }
        Self {
            range: 0..=magics.len() - 1,
            all,
            magics,
        }
    }
}

#[derive(Debug)]
pub(super) struct Magics<T> {
    pub(super) bishop: Magic<T>,
    pub(super) rook: Magic<T>,
    pub(super) king: BitBoard,
}

impl<T> Magics<T>
where
    T: Index<usize, Output = BitBoard>,
{
    pub fn bishop_reachable(&self, occupied: BitBoard) -> BitBoard {
        self.bishop.f(occupied)
    }

    pub fn pro_bishop_reachable(&self, occupied: BitBoard) -> BitBoard {
        self.bishop.f(occupied) | self.king
    }

    pub fn rook_reachable(&self, occupied: BitBoard) -> BitBoard {
        self.rook.f(occupied)
    }

    pub fn pro_rook_reachable(&self, occupied: BitBoard) -> BitBoard {
        self.rook.f(occupied) | self.king
    }

    pub(super) fn check(&self, pos: Square) {
        let mut rng = StdRng::seed_from_u64(202501202000 + pos.index() as u64);
        for _ in 0..10000 {
            let one_prob_per_100 = rng.gen_range(1..50);
            let mut occupied = BitBoard::EMPTY;
            for pos in Square::iter() {
                if rng.gen_range(0..100) < one_prob_per_100 {
                    occupied.set(pos);
                }
            }
            assert_eq!(
                self.bishop.f(occupied),
                bishop_reachable_no_magic(occupied, pos)
            );
            assert_eq!(
                self.rook.f(occupied),
                rook_reachable_no_magic(occupied, pos)
            );
        }
    }
}

impl Magics<Vec<BitBoard>> {
    fn total_len(&self) -> usize {
        self.bishop.table.len() + self.rook.table.len()
    }
}

pub(crate) type Magic<T> = crate::magic::Magic<T>;

fn gen_magics<R: SeedableRng + Rng>(
    generator: &mut MagicGenerator<R>,
    pos: Square,
) -> anyhow::Result<Magics<Vec<BitBoard>>> {
    let mut bishop_full = bishop_power(pos);
    let mut rook_full = rook_power(pos);
    for edge in [
        BitBoard::COL1,
        BitBoard::COL9,
        BitBoard::ROW1,
        BitBoard::ROW9,
    ] {
        if !edge.contains(pos) {
            rook_full.and_not_assign(edge);
            bishop_full.and_not_assign(edge);
        }
    }

    let bishop_map = bishop_full
        .subsets()
        .map(|bb| (bb, bishop_reachable_no_magic(bb, pos)))
        .collect();
    let rook_map = rook_full
        .subsets()
        .map(|bb| (bb, rook_reachable_no_magic(bb, pos)))
        .collect();

    let rook = generator.gen_magic(rook_map, &format!("rook {:?}", pos))?;
    let bishop = generator.gen_magic(bishop_map, &format!("bishop {:?}", pos))?;

    Ok(Magics {
        bishop,
        rook,
        king: king_power(pos),
    })
}
