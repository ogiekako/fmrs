use std::{
    collections::HashMap,
    fs::File,
    io::Write,
    ops::{Index, Range, RangeInclusive},
    path::PathBuf,
    time::Instant,
};

use crate::position::{
    bitboard::{bishop_reachable_no_magic, king_power, rook_reachable_no_magic},
    BitBoard, Square,
};
use log::{debug, info};
use quote::{quote, ToTokens, TokenStreamExt};
use rand::{rngs::StdRng, Rng, SeedableRng};
use rayon::prelude::*;

pub fn gen_magic<R: SeedableRng + Rng>() -> anyhow::Result<()> {
    let start = Instant::now();

    let one_prob_per_100 = 10..21;

    let range = Square::S11.index()..=Square::S99.index();

    let all_magics = range
        .clone()
        .into_par_iter()
        .map(|i| {
            let pos = Square::from_index(i);
            info!("generating magics for {:?}", pos);

            let mut generator = MagicGenerator {
                rng: R::seed_from_u64(i as u64),
                one_prob_per_100: one_prob_per_100.clone(),
                max_iter: 10_000_000,
                max_retry: 100,
            };
            generator.gen_magics(pos)
        })
        .collect::<Result<Vec<_>, _>>()?;

    let elapsed = start.elapsed();

    all_magics
        .par_iter()
        .zip(range.clone().collect::<Vec<_>>())
        .for_each(|(magics, i)| {
            magics.check(Square::from_index(i));
        });

    let total_len: usize = all_magics.iter().map(|m| m.total_len()).sum();
    info!(
        "found {} magics in {:.1?}; total length: {}",
        all_magics.len(),
        elapsed,
        total_len,
    );

    let mut const_magics: ConstMagics = all_magics.as_slice().into();
    const_magics.range = range;

    let comment = format!("Generated by gen-magic: total_len={total_len} elapsed={elapsed:.1?}");

    let mut ts = quote! {};
    ConstMagics::write_def(&mut ts);
    const_magics.write_value(&mut ts);

    let file = PathBuf::from(file!());
    let dir = file.parent().unwrap();
    let included_file_name = "generated_magics_incl.rs";

    writeln!(&mut File::create(dir.join(included_file_name))?, "{}", ts)?;

    let ts = quote! {
        #![cfg_attr(any(), rustfmt::skip)]
        #![allow(clippy::all, unused)]
        #[doc = #comment]
        include!(#included_file_name);
    };
    writeln!(
        &mut File::create(dir.join("generated_magics.rs"))?,
        "{}",
        ts
    )?;

    Ok(())
}

struct Offset(usize);

impl Index<usize> for Offset {
    type Output = BitBoard;

    fn index(&self, _index: usize) -> &Self::Output {
        unimplemented!("dummy")
    }
}

struct ConstMagics {
    range: RangeInclusive<usize>,
    all: Vec<BitBoard>,
    magics: Vec<Magics<Offset>>,
}

trait WriteCode {
    fn write_def(_w: &mut impl TokenStreamExt) {}
    fn write_value(&self, w: &mut impl TokenStreamExt);
    fn tokens(&self) -> impl TokenStreamExt + ToTokens {
        let mut w = quote! {};
        self.write_value(&mut w);
        w
    }
}

impl WriteCode for Offset {
    fn write_def(w: &mut impl TokenStreamExt) {
        w.append_all(quote! {
            pub struct Offset(usize);
            impl std::ops::Index<usize> for Offset {
                type Output = BitBoard;
                fn index(&self, index: usize) -> &Self::Output {
                    &ALL[index + self.0]
                }
            }
        });
    }
    fn write_value(&self, w: &mut impl TokenStreamExt) {
        let x = self.0;
        w.append_all(quote! {
            Offset(#x)
        });
    }
}

impl WriteCode for BitBoard {
    fn write_def(w: &mut impl TokenStreamExt) {
        w.append_all(quote! {
            use crate::position::bitboard::BitBoard;
            const fn b(x: u128) -> BitBoard {
                BitBoard::from_u128(x)
            }
        });
    }
    fn write_value(&self, w: &mut impl TokenStreamExt) {
        let x = self.u128();
        w.append_all(quote! {
            b(#x)
        });
    }
}

impl<T: WriteCode> WriteCode for Vec<T> {
    fn write_value(&self, w: &mut impl TokenStreamExt) {
        let mut tokens = vec![];
        for x in self {
            tokens.push(x.tokens());
        }
        w.append_all(quote! {
            [#(#tokens),*]
        });
    }
}

impl WriteCode for Magics<Offset> {
    fn write_def(w: &mut impl TokenStreamExt) {
        w.append_all(quote! {
            use crate::position::bitboard::rule::magics_generator::Magics;
        });
    }
    fn write_value(&self, w: &mut impl TokenStreamExt) {
        let bishop = self.bishop.tokens();
        let rook = self.rook.tokens();
        w.append_all(quote! {
            Magics {
                bishop: #bishop,
                rook: #rook,
            }
        });
    }
}

impl WriteCode for Magic<Offset> {
    fn write_def(w: &mut impl TokenStreamExt) {
        w.append_all(quote! {
            use crate::position::bitboard::rule::magics_generator::Magic;
        });
    }
    fn write_value(&self, w: &mut impl TokenStreamExt) {
        let pack_shift = self.pack_shift;
        let magic_shift = self.magic_shift;
        let full_block = self.full_block.tokens();
        let magic = self.magic;
        let king = self.king.tokens();
        let table = self.table.tokens();
        w.append_all(quote! {
            Magic {
                pack_shift: #pack_shift,
                magic_shift: #magic_shift,
                full_block: #full_block,
                magic: #magic,
                king: #king,
                table: #table,
            }
        });
    }
}

impl ConstMagics {
    fn write_def(w: &mut impl TokenStreamExt) {
        w.append_all(quote! {
            use crate::position::bitboard::Square;
        });
        BitBoard::write_def(w);
        Offset::write_def(w);
        Magic::<Offset>::write_def(w);
        Magics::<Offset>::write_def(w);
    }
    fn write_value(&self, w: &mut impl TokenStreamExt) {
        let all = self.all.tokens();
        let magics = self.magics.tokens();
        let all_len = self.all.len();
        let magics_len = self.magics.len();
        let start = self.range.start();
        let end = self.range.end();
        w.append_all(quote! {
            const ALL: [BitBoard; #all_len] = #all;
            const MAGICS: [Magics<Offset>; #magics_len] = #magics;

            pub fn bishop_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
                MAGICS[pos.index()].bishop.reachable(occupied)
            }
            pub fn pro_bishop_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
                MAGICS[pos.index()].bishop.pro_reachable(occupied)
            }
            pub fn rook_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
                MAGICS[pos.index()].rook.reachable(occupied)
            }
            pub fn pro_rook_reachable(occupied: BitBoard, pos: Square) -> BitBoard {
                MAGICS[pos.index()].rook.pro_reachable(occupied)
            }

            #[cfg(test)]
            mod tests {
                use super::*;

                #[test]
                fn test_const_magics() {
                    for (magics, i) in MAGICS.iter().zip(#start..=#end) {
                        magics.check(Square::from_index(i));
                    }
                }
            }
        });
    }
}

impl From<&[Magics<Vec<BitBoard>>]> for ConstMagics {
    fn from(all_magics: &[Magics<Vec<BitBoard>>]) -> Self {
        let mut all = vec![];

        let mut magics = vec![];
        for m in all_magics {
            let bishop = m.bishop.clone_with(Offset(all.len()));
            all.extend_from_slice(&m.bishop.table);
            let rook = m.rook.clone_with(Offset(all.len()));
            all.extend_from_slice(&m.rook.table);

            magics.push(Magics { bishop, rook });
        }
        Self {
            range: 0..=magics.len() - 1,
            all,
            magics,
        }
    }
}

#[derive(Debug)]
pub(super) struct Magics<T> {
    pub(super) bishop: Magic<T>,
    pub(super) rook: Magic<T>,
}

impl<T> Magics<T>
where
    T: Index<usize, Output = BitBoard>,
{
    pub(super) fn check(&self, pos: Square) {
        let mut rng = StdRng::seed_from_u64(202501202000 + pos.index() as u64);
        for _ in 0..10000 {
            let one_prob_per_100 = rng.gen_range(1..50);
            let mut occupied = BitBoard::EMPTY;
            for pos in Square::iter() {
                if rng.gen_range(0..100) < one_prob_per_100 {
                    occupied.set(pos);
                }
            }
            assert_eq!(
                self.bishop.reachable(occupied),
                bishop_reachable_no_magic(occupied, pos)
            );
            assert_eq!(
                self.bishop.pro_reachable(occupied),
                bishop_reachable_no_magic(occupied, pos) | king_power(pos)
            );
            assert_eq!(
                self.rook.reachable(occupied),
                rook_reachable_no_magic(occupied, pos)
            );
            assert_eq!(
                self.rook.pro_reachable(occupied),
                rook_reachable_no_magic(occupied, pos) | king_power(pos)
            );
        }
    }
}

impl Magics<Vec<BitBoard>> {
    fn total_len(&self) -> usize {
        self.bishop.table.len() + self.rook.table.len()
    }
}

#[derive(Clone, Debug)]
pub(super) struct Magic<T> {
    pub(super) pack_shift: u32,
    pub(super) magic_shift: u32,
    pub(super) full_block: BitBoard,
    pub(super) magic: u64,
    pub(super) king: BitBoard,
    pub(super) table: T,
}

impl<T> Magic<T>
where
    T: Index<usize, Output = BitBoard>,
{
    pub(super) fn reachable(&self, occupied: BitBoard) -> BitBoard {
        let packed = pack(occupied & self.full_block, self.pack_shift);
        self.table[(self.magic.wrapping_mul(packed) >> self.magic_shift) as usize]
    }

    pub(super) fn pro_reachable(&self, occupied: BitBoard) -> BitBoard {
        self.reachable(occupied) | self.king
    }
}

impl<T> Magic<T> {
    fn clone_with<S>(&self, table: S) -> Magic<S> {
        Magic {
            pack_shift: self.pack_shift,
            magic_shift: self.magic_shift,
            full_block: self.full_block,
            magic: self.magic,
            king: self.king,
            table,
        }
    }
}

struct MagicGenerator<R: SeedableRng + Rng> {
    rng: R,
    one_prob_per_100: Range<u8>,
    max_iter: usize,
    max_retry: usize,
}

impl<R: SeedableRng + Rng> MagicGenerator<R> {
    fn gen_magics(&mut self, pos: Square) -> anyhow::Result<Magics<Vec<BitBoard>>> {
        let rook = self.gen_magic(pos, rook_reachable_no_magic, "rook")?;
        let bishop = self.gen_magic(pos, bishop_reachable_no_magic, "bishop")?;

        Ok(Magics { bishop, rook })
    }

    fn gen_magic<F>(
        &mut self,
        pos: Square,
        reachable: F,
        kind: &str,
    ) -> anyhow::Result<Magic<Vec<BitBoard>>>
    where
        F: Fn(BitBoard, Square) -> BitBoard,
    {
        let mut full_block = reachable(BitBoard::EMPTY, pos);
        for edge in [
            BitBoard::COL1,
            BitBoard::COL9,
            BitBoard::ROW1,
            BitBoard::ROW9,
        ] {
            if !edge.contains(pos) {
                full_block.and_not_assign(edge);
            }
        }

        let mut res = None;

        for _ in 0..self.max_retry {
            if res.is_some() {
                break;
            }
            for pack_shift in 0..64 {
                if res.is_some() {
                    break;
                }
                if pack(full_block, pack_shift).count_ones() != full_block.count_ones() {
                    continue;
                }

                let mut map: HashMap<_, Vec<u64>> = HashMap::new();
                for block in full_block.subsets() {
                    let reach = reachable(block, pos);
                    map.entry(reach).or_default().push(pack(block, pack_shift));
                }
                let smallest_table_log2 = map.len().next_power_of_two().ilog2();
                let largest_table_log2 = map
                    .values()
                    .map(Vec::len)
                    .sum::<usize>()
                    .next_power_of_two()
                    .ilog2();

                for table_log2 in (smallest_table_log2..=largest_table_log2).rev() {
                    let kvs = map.iter().collect::<Vec<_>>();
                    let values = kvs.iter().map(|(_, v)| *v).collect::<Vec<_>>();

                    let mut table: Vec<u8> = vec![0; 1 << table_log2];
                    for iter in 0..self.max_iter {
                        let magic = random_u64(&mut self.rng, &self.one_prob_per_100);

                        table.fill(u8::MAX);
                        if !create_table(&values, magic, &mut table, table_log2) {
                            continue;
                        };

                        info!(
                            "{kind} magic found on {pos:?} (iter={iter}) {}/{} (pack_shift={pack_shift})",
                            1 << table_log2,
                            map.len(),
                        );

                        let bitboards: Vec<BitBoard> = table
                            .iter()
                            .map(|&x| kvs.get(x as usize).map(|x| *x.0).unwrap_or_default())
                            .collect();

                        res = Some(Magic {
                            pack_shift,
                            magic_shift: u64::BITS - table_log2,
                            full_block,
                            magic,
                            king: king_power(pos),
                            table: bitboards,
                        });
                        break;
                    }

                    if res.is_none() && table_log2 == largest_table_log2 {
                        debug!(
                            "{kind} magic not found on {pos:?} after {} iterations (shift={pack_shift})",
                            self.max_iter,
                        );
                    }
                }
            }
        }
        res.ok_or_else(|| {
            anyhow::anyhow!(
                "{kind} magic for {pos:?} not found after {} iterations and {} retries",
                self.max_iter,
                self.max_retry,
            )
        })
    }
}

fn pack(bb: BitBoard, shift: u32) -> u64 {
    let x = bb.u128();
    let lower = (x as u64).rotate_left(shift);
    let upper = (x >> 64) as u64;
    lower | upper
}

fn create_table(map: &Vec<&Vec<u64>>, magic: u64, table: &mut [u8], table_log2: u32) -> bool {
    let shift = u64::BITS - table_log2;
    for (i, &blocks) in map.iter().enumerate() {
        let i = i as u8;
        for &block in blocks {
            let j = (magic.wrapping_mul(block) >> shift) as usize;
            if table[j] == i {
                continue;
            }
            if table[j] != u8::MAX {
                return false;
            }
            table[j] = i;
        }
    }
    true
}

fn random_u64<R: Rng>(rng: &mut R, one_prob_per_100: &Range<u8>) -> u64 {
    let mut magic = 0;
    let one_prob_per_100 = rng.gen_range(one_prob_per_100.clone());
    for i in 0..u64::BITS {
        if rng.gen_range(0u8..100) < one_prob_per_100 {
            magic |= 1u64 << i;
        }
    }
    magic
}
